#!/usr/bin/env ruby
# require 'optparse'
require 'json'
# TODO: add a parameter to configure this
configfile = 'syncwatch.json'

# This script runs forever unless killed, so handle ^C nicely
trap('INT') {
  puts ''
  puts 'Syncwatch shutting down.'
  exit
}

# Open and parse the JSON config file
def read_config(configfile)
  begin
    file = File.read(configfile)
    parsed_config = JSON.parse(file)
  rescue => error
    abort("ERROR: Error parsing configuration file #{configfile}. Does it exist and is it valid JSON?")
  end
  return parsed_config
end

# Start a watch thread
def start_watch(sourcedir, remotedir, remotehost, watchid)
  # fswatch options
  # -1 to make it exit after one iteration, this seems to be most reliable way to avoid it triggering multiple syncs per event
  # -r to watch recursively
  # -L to follow symlinks
  # --event because only these three events actually change anything
  watch_cmd = "fswatch -1 -rL --event Updated --event Removed --event Created \"#{sourcedir}\""
  loop do
    `#{watch_cmd}`
    puts "  [#{watchid}] Syncing #{sourcedir} to #{remotehost}:#{remotedir}"
    # TODO: configurable rsync options
    sync_cmd = "rsync -rvz --delete #{sourcedir} #{remotehost}:#{remotedir} &>/dev/null"
    `#{sync_cmd}`
  end
end

# Start a watch thread for the configuration file
def start_config_watch(configfile)
  # This command will hang this thread until the configuration file has changed
  # These options make fswatch it exit after an update to the file
  config_watch_cmd = "fswatch -1 --event Updated \"#{configfile}\""
  `#{config_watch_cmd}`
end

def exit_watches()
  # puts Thread.current.inspect
  puts "[0] Configuration changed, stopping all watches and reloading"
  Thread.list.each do |thread|
    if (thread != Thread.main && thread != Thread.current)
      thread.exit
    end
  end
end

# An infinite loop allows this script to restart when the configuration file changes
loop do
  # Start a thread for each set of source and destination locations in the config file
  watch_threads=[]
  config = read_config(configfile)
  # Add the config watch thread to the pool as the first watch
  puts "Starting new watch [0] on #{configfile}"
  watch_threads << Thread.new{start_config_watch(configfile); exit_watches()}
  # Create a thread for each user defined watch
  config.each_with_index do |watch, index|
    watchid = index+1
     puts "Starting new watch [#{watchid}] on #{watch['sourcedir']}"
     watch_threads << Thread.new{start_watch(watch['sourcedir'], watch['remotedir'], watch['remotehost'], watchid)}
  end

  # Start all threads and wait for them to end
  watch_threads.each {|t| t.join}
end
